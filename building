Prompt Constraint for Select/GroupBy SQL Clause Generator Agent

🔧 Constraint for Query Structure Generation:
	•	Always generate multi-step Top-N queries using Common Table Expressions (CTEs) for clarity and modularity.
	•	The structure must follow this logical pattern:
	1.	CTE 1 (top_k_base): Select top K values for a base category (e.g., top 10 countries, top 5 capsules) using GROUP BY + ORDER BY COUNT(*) or another aggregate.
	2.	CTE 2 (metric_by_item): For each top category value, group and compute the desired metric (e.g., count, avg, sum, percentile) per sub-item (e.g., nltext, capsuleid, clienttype).
	3.	CTE 3 (ranked_items): Use ROW_NUMBER() or RANK() with PARTITION BY <category> and ORDER BY <metric> DESC to rank sub-items per category.
	4.	Final SELECT: Return only top N ranked items per category using WHERE rank <= N.
	•	Always use fully qualified column names in GROUP BY and ORDER BY to avoid ambiguity.
	•	Support multiple metric types: COUNT(*), AVG(...), PERCENTILE_CONT(...), COUNT(DISTINCT ...), etc.
	•	Avoid database-specific functions unless the target SQL dialect is specified.

⸻

🏗️ Constraint for BigQuery SQL Generator Agent

🔒 BigQuery-Specific Constraints:
	•	Ensure partition pruning is respected by applying WHERE yyyymmdd BETWEEN DATE 'YYYY-MM-DD' AND DATE 'YYYY-MM-DD' directly if yyyymmdd is a DATE type.
	•	❌ Do not use PARSE_DATE, CAST, or wrap yyyymmdd in functions in the WHERE clause.
	•	Use SAFE_CAST only when absolutely necessary and only in SELECT or GROUP BY, never inside the partition filter.
	•	Use PERCENTILE_CONT() for percentile-based metrics.
	•	Always quote table names using backticks (`project.dataset.table`).
	•	Limit result size when necessary using LIMIT <N>.
	•	Order by metric descending (ORDER BY metric DESC) unless specified otherwise.

⸻

📌 Bonus Example Template the Agent Can Generalize From:

WITH top_k_categories AS (
  SELECT country
  FROM `project.dataset.table`
  WHERE yyyymmdd BETWEEN DATE '2024-11-01' AND DATE '2025-04-03'
  GROUP BY country
  ORDER BY COUNT(*) DESC
  LIMIT 10
),
metric_by_item AS (
  SELECT country, capsuleid, AVG(SAFE_CAST(e2e AS FLOAT64)) AS avg_latency
  FROM `project.dataset.table`
  WHERE yyyymmdd BETWEEN DATE '2024-11-01' AND DATE '2025-04-03'
    AND country IN (SELECT country FROM top_k_categories)
  GROUP BY country, capsuleid
),
ranked_items AS (
  SELECT *,
         ROW_NUMBER() OVER (PARTITION BY country ORDER BY avg_latency DESC) AS rank
  FROM metric_by_item
)
SELECT country, capsuleid, avg_latency
FROM ranked_items
WHERE rank <= 5
ORDER BY country, avg_latency DESC;

import java.util.*;

class UserSolution {
    class Building {
        int address;
        int length;

        public Building(int address, int length) {
            this.address = address;
            this.length = length;
        }
    }

    class Space {
        int address;
        int length;

        public Space(int address, int length) {
            this.address = address;
            this.length = length;
        }

        // Needed for PriorityQueue.remove() to work properly
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            Space other = (Space) obj;
            return address == other.address && length == other.length;
        }

        @Override
        public int hashCode() {
            return Objects.hash(address, length);
        }
    }

    TreeMap<Integer, Space> spaceMap = new TreeMap<>();
    HashMap<Integer, Building> buildMap = new HashMap<>();
    PriorityQueue<Space> pq = new PriorityQueue<>((a, b) -> {
        if (a.length != b.length) return b.length - a.length;
        return a.address - b.address;
    });

    public void init(int N) {
        spaceMap.clear();
        buildMap.clear();
        pq.clear();
        Space initial = new Space(0, N);
        spaceMap.put(0, initial);
        pq.offer(initial);
    }

    public int build(int mLength) {
        while (!pq.isEmpty()) {
            Space unoccupied = pq.poll();
            // Skip stale entries
            if (!spaceMap.containsKey(unoccupied.address) ||
                spaceMap.get(unoccupied.address).length != unoccupied.length) {
                continue;
            }

            if (unoccupied.length < mLength) return -1;

            spaceMap.remove(unoccupied.address);

            int occStart = ((unoccupied.length - mLength) / 2) + unoccupied.address;
            Building occupied = new Building(occStart, mLength);
            buildMap.put(occStart, occupied);

            // Left segment
            if (occStart > unoccupied.address) {
                Space left = new Space(unoccupied.address, occStart - unoccupied.address);
                spaceMap.put(left.address, left);
                pq.offer(left);
            }

            // Right segment
            int rightStart = occStart + mLength;
            int rightLength = unoccupied.length - (mLength + (occStart - unoccupied.address));
            if (rightLength > 0) {
                Space right = new Space(rightStart, rightLength);
                spaceMap.put(right.address, right);
                pq.offer(right);
            }

            return occStart;
        }

        return -1;
    }

    public int demolish(int mAddr) {
        if (!buildMap.containsKey(mAddr)) return -1;

        Building occ = buildMap.remove(mAddr);
        int occStart = occ.address;
        int occEnd = occStart + occ.length;

        Integer leftKey = spaceMap.lowerKey(occStart);
        Integer rightKey = spaceMap.higherKey(occStart);

        Space left = (leftKey != null) ? spaceMap.get(leftKey) : null;
        Space right = (rightKey != null) ? spaceMap.get(rightKey) : null;

        boolean mergeLeft = (left != null && (left.address + left.length == occStart));
        boolean mergeRight = (right != null && (occEnd == right.address));

        if (mergeLeft && mergeRight) {
            // Merge with both
            pq.remove(left);
            pq.remove(right);
            spaceMap.remove(right.address);
            left.length += occ.length + right.length;
            pq.offer(left);
        } else if (mergeLeft) {
            // Merge with left
            pq.remove(left);
            left.length += occ.length;
            pq.offer(left);
        } else if (mergeRight) {
            // Merge with right
            pq.remove(right);
            spaceMap.remove(right.address);
            Space merged = new Space(occStart, occ.length + right.length);
            spaceMap.put(merged.address, merged);
            pq.offer(merged);
        } else {
            // No merge
            Space newSpace = new Space(occStart, occ.length);
            spaceMap.put(occStart, newSpace);
            pq.offer(newSpace);
        }

        return occ.length;
    }
}


public int demolish(int mAddr) {
		if(!buildMap.containsKey(mAddr)) {
			return -1;
		}
		building occ = buildMap.remove(mAddr);
		ArrayList<Integer> al = new ArrayList<>(spaceMap.keySet());
		if(mAddr < al.get(0)) {
			if((occ.address + occ.length == al.get(0))){
				space unocc = spaceMap.remove(al.get(0));
				pq.remove(new space(al.get(0), unocc.length));
				unocc.address = mAddr;
				unocc.length = occ.length + unocc.length;
				spaceMap.put(mAddr, unocc);
				pq.offer(unocc);
				return occ.length;
			}
			else {
				space newunocc = new space(mAddr, occ.length);
				spaceMap.put(mAddr, newunocc);
				pq.offer(newunocc);
				return occ.length;
			}
		}
		if(mAddr > al.get(al.size() - 1)) {
			space unocc = spaceMap.get(al.get(al.size() - 1));
			if(unocc.address + unocc.length == occ.address) {
				pq.remove(new space(unocc.address, unocc.length));
				unocc.length = occ.length + unocc.length;
				pq.offer(unocc);
				return occ.length;
			}
			else {
				space newunocc = new space(mAddr, occ.length);
				pq.offer(newunocc);
				spaceMap.put(mAddr, newunocc);
				return occ.length;
			}
		}
		
		int s = 0;
		int l = al.size() - 1;
		while(s <= l) {
			int mid = s + ((l - s) / 2);
	
			if(mAddr < al.get(mid)) {
				l = mid - 1;
			}
			else if(mAddr > al.get(mid)) {
				s = mid + 1;
			}
			else {
				break;
			}
		}
		
		int s1 = al.get(l);
		int s2 = al.get(l + 1);
		if(s1 + spaceMap.get(s1).length == occ.address && occ.address + occ.length == s2) {
			space unocc1 = spaceMap.get(s1);
			space unocc2 = spaceMap.remove(s2);
			pq.remove(new space(s1, unocc1.length));
			pq.remove(new space(s2, unocc2.length));
			unocc1.length = unocc1.length + unocc2.length + occ.length;
			pq.add(unocc1);
			return occ.length;
		}
		else if(s1 + spaceMap.get(s1).length == occ.address && occ.address + occ.length != s2) {
			space unocc1 = spaceMap.get(s1);
			pq.remove(new space(s1, unocc1.length));
			unocc1.length = unocc1.length + occ.length;
			pq.add(unocc1);
			return occ.length;
		}
		else if(s1 + spaceMap.get(s1).length != occ.address && occ.address + occ.length == s2) {
			space unocc2 = spaceMap.remove(s2);
			pq.remove(new space(s2, unocc2.length));
			unocc2.length = unocc2.length + occ.length;
			unocc2.address = mAddr;
			pq.add(unocc2);
			return occ.length;
		}
		else {
			space newunocc = new space(mAddr, occ.length);
			pq.add(newunocc);
			spaceMap.put(mAddr, newunocc);
			return occ.length;
		}
		
		
	}
